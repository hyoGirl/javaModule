


# 1：Proxy
基于java的动态代理实现


# 2：Template

模板模式
  主要側重點：
- 1：使用final來限定抽象类中方法执行顺序
- 2：分离可变和不可变部分，让子类有选择的去继承重写方法
- 3：使用Protected 限定了算法的具体类实现只对子类开放


# 3：Decorator

装饰者模式



- 1： 被装饰者 Component    是存在的一个抽象。可以是abstract类也可以是一个interface。也可以称为抽象被装饰类
- 2： 真实被装饰类，ConcreteComponent   也是针对于component的具体实现。

- 3： Decorator   装饰类  真实装饰类，具体的呈现对真实被装饰类的功能进行强化。
      携带了一个执向Componet的指针，并且定义一个和Component一样的接口

## 与代理模式的区别

- 1：相似点，装饰者 和真实的被装饰者 都可以说实现了同一个接口
- 2： 代理类和被代理类 也差不多，都是有个上层接口

- 3：区别在于：  装饰器模式可以装饰多个对象，对象变动是灵活的。代理模式中代理类与被代理类是固定的，甚至是写死在代理类内部。 



# 主要用途

- 1：当程序需要扩展现有的功能时，
- 2：单独使用继承或者组合存在维护复杂，代码过多的问题时

# 优点
- 1：区别类的核心职责与装饰职责，降低了程序的耦合度
- 2：提供相对继承 能组合更强大的功能，无须修改组件

参考文章： https://blog.csdn.net/u012403290/article/details/71747516   wrapper

# 4：Observer

观察者模式

- 1： 被观察者  Observerable     是存在的一个抽象。可以是abstract类也可以是一个interface。也可以称为抽象被观察类
      它把所有对观察者对象的引用保存在一个集合中，每个主题都可以有任意数量的观察者。抽象主题提供一个接口，可以增加和删除观察者角色。一般用一个抽象类     和接口来实现。
- 2： 抽象观察者类，  为所有的具体观察者定义一个接口，在得到主题通知时更新自己。
- 3： 具体被观察者角色  也就是一个具体的主题，在集体主题的内部状态改变时，所有登记过的观察者发出通知。
- 4： 具体观察者角色：实现抽象观察者角色所需要的更新接口，一边使本身的状态与制图的状态相协调。

- 3： Decorator   装饰类  真实装饰类，具体的呈现对真实被装饰类的功能进行强化。
      携带了一个执向Componet的指针，并且定义一个和Component一样的接口
参考网站： https://www.cnblogs.com/luohanguo/p/7825656.html
